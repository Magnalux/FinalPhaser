<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Phaser Project 1</title>
        <link rel="stylesheet" type="text/css" href="css/main.css">
        <script src="js/phaser.min.js"></script>
    </head>
    <body>
        <!-- <h1 class="center-text">Destroy the Castle</h1> -->
        <div id="gameArea"></div>
        
        <script type="text/javascript">
            /*
            FOR NEXT ITERATION:
            Goal: make the camera follow one fighter as they walk around
            Due:  next wednesday, 4/4
            Steps:
            By end of monday:
            1.  Draw the animation sheet for the paladin-type fighter
                a.  Moving Right
                b.  Moving Left
                c.  Jumping
                d.  Landing
                e.  Attacking
                f.  Shielding
                g.  Dieing
                h.  Taking Damage (minor)
                i.  Taking Damage (moderate)
                j.  Taking Damage (major, should get flown back)
                
                Only two possible directions to face: just flip the image horizontally to face the other direction
            
            By end of wednesday:
            2.  Make the fighter be animated to move right all the time
            3.  Make the fighter animated only when a directional key is pressed (use 'wasd' controls)
            4.  Make the fighter move with the animation when a directional key is pressed
            5.  Make the fighter jump when space is pressed
            
            There does not need to be complex terrain (yet). Just make sure there are some platforms to jump on in order to test movement
            */

            window.onload = function() {
                var MAP_WIDTH = 4000;
                var MAP_HEIGHT = 800;
                var ICON_WIDTH = 100;
                var BAR_MAX_LENGTH = 256;
                var BAR_HEIGHT = 15;
                var GRAVITY = 400;
                var GRENADE_VELOCITY = 500;
                var EXPLOSION_VELOCITY = 300;
                var GRENADE_LIFETIME = 400;
                var EXPLOSION_LIFETIME = 300;
                var CAMERA_SPEED = 20;
                var game = new Phaser.Game(800, 600, Phaser.AUTO, 'gameArea', { preload: preload, create: create, update: update });
                var platformCollisionGroup;
                var objectCollisionGroup;
                var objects;
                var fighterCollisionGroup;
                var grenadeCollisionGroup;
                var grenadeCollided;
                var projectiles;
                var shardCollisionGroup;
                var mouseWasDown = false;
                var currentLevel;
                var teams;
                var gameState;
                var fighterStats;
                var inputKeys;
                var actionMenu;
                var selectMenu;

                function preload () {
                    game.load.image('background', 'img/Background.png');
                    game.load.image('blackbox', 'img/Blackbox.png');
                    game.load.image('graybox', 'img/Graybox.png');
                    game.load.image('button', 'img/Graybox.png');
                    game.load.image('ground', 'img/Ground.png');
                    game.load.image('grenade', 'img/Grenade.png');
                    game.load.image('explosion', 'img/Shard.png');
                    game.load.image('person', 'img/Person.png');
                    game.load.image('activeiconoverlay', 'img/ActiveIconOverlay.png');
                }

                function create () {
                    game.stage.backgroundColor = "#555555";
                    game.world.setBounds(0, 0, MAP_WIDTH, MAP_HEIGHT);
                    
                    game.physics.startSystem(Phaser.Physics.P2JS);
                    
                    game.physics.p2.setImpactEvents(true);
                    
                    game.physics.p2.gravity.y = GRAVITY;
                    
                    objectCollisionGroup = game.physics.p2.createCollisionGroup();
                    platformCollisionGroup = game.physics.p2.createCollisionGroup();
                    fighterCollisionGroup = game.physics.p2.createCollisionGroup();
                    grenadeCollisionGroup = game.physics.p2.createCollisionGroup();
                    shardCollisionGroup = game.physics.p2.createCollisionGroup();
                    game.physics.p2.updateBoundsCollisionGroup();
                    
                    
                    
                    //Initialize background
                    var background = game.add.sprite(0, 0, 'background');
                    background.fixedToCamera = true;
                    
                    
                    
                    //NOTE: phaser objects can only be in one group at a time!
                    
                    
                    
                    //Initialize keyboard inputs
                    inputManager = new Object();
                    
                    //Initialize the input mode
                    inputManager.state = "move"
                    inputManager.movingLeft = false;
                    
                    //Initialize specific key inputs
                    inputManager.key_W = game.input.keyboard.addKey(Phaser.Keyboard.W);
                    inputManager.key_W.onDown.add(wPressed, this);
                    inputManager.key_A = game.input.keyboard.addKey(Phaser.Keyboard.A);
                    inputManager.key_A.onDown.add(aPressed, this);
                    inputManager.key_D = game.input.keyboard.addKey(Phaser.Keyboard.D);
                    inputManager.key_D.onDown.add(dPressed, this);
                    inputManager.key_S = game.input.keyboard.addKey(Phaser.Keyboard.S);
                    inputManager.key_S.onDown.add(sPressed, this);
                    inputManager.key_SPACEBAR = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
                    inputManager.key_SPACEBAR.onDown.add(spacePressed, this);
                    
                    
                    
                    //Initialize the lists for each projectile
                    projectiles = new Object();
                    projectiles.grenades = game.add.group();
                    projectiles.grenades.enableBody = true;
                    projectiles.grenades.physicsBodyType = Phaser.Physics.P2JS;
                    
                    projectiles.shards = game.add.group();
                    projectiles.shards.enableBody = true;
                    projectiles.shards.physicsBodyType = Phaser.Physics.P2JS;

                    
                    
                    //Initialize Game State Variable
                    gameState = new Object();
                    gameState.currentState = "selectmenu";
                    gameState.activeFighter = null;
                    gameState.activeTeam = 1;
                    
                    
                    
                    //Initialize fighter stats
                    fighterStats = new Object();
                    fighterStats.paladin = new Object();
                    fighterStats.paladin.jumpSpeed = 200;
                    fighterStats.paladin.moveSpeed = 150;
                    fighterStats.paladin.maxDistance = 150;
                    fighterStats.paladin.numJumps = 1;
                    fighterStats.paladin.attackRange = 100;
                    fighterStats.paladin.attackDamage = 20;
                    fighterStats.paladin.maxHealth = 50;
                    
                    
                    //Initialize the menu
                    toSelectMenu();
                }
                
                function toSelectMenu() {
                    deleteLevel();
                    gameState.currentState = "selectmenu";
                    inputManager.state = "move";
                    
                    //Delete any select menu that might exist
                    deleteSelectMenu();
                    
                    //Set up the camera's position
                    game.camera.unfollow();
                    game.camera.x = 0;
                    game.camera.y = 0;
                    
                    selectMenu = new Object();
                    selectMenu.testText = game.add.text(5, 5, "Click the gray square to start", { fill: "#ffffff", font: "14pt Arial" });
                    selectMenu.testText.fixedToCamera = true;
                    selectMenu.testText.cameraOffset.x = (game.width - selectMenu.testText.width) / 2;
                    
                    selectMenu.testButton = game.add.button(200, 150, "button", actionOnClick, this);
                    selectMenu.testButton.fixedToCamera = true;
                }
                
                function deleteSelectMenu() {
                    if (selectMenu != null) {
                        if (selectMenu.testText != null) {
                            selectMenu.testText.destroy();
                        }
                        if (selectMenu.testButton != null) {
                            selectMenu.testButton.destroy();
                        }
                        console.log(selectMenu);
                        //selectMenu.destroy();
                    }
                }
                
                function actionOnClick() {
                    deleteSelectMenu();
                    
                    currentLevel = 0;
                    loadLevel(currentLevel);
                }
                
                function loadLevel(levelIdx) {
                    //Delete any levels that might exist
                    deleteLevel();
                    
                    //Update the gamestate
                    gameState.currentState = "game";
                    
                    //Initialize the teams
                    teams = new Object();
                    //Initialize the left team
                    teams.leftTeam = game.add.group();
                    teams.leftTeam.enableBody = true;
                    teams.leftTeam.physicsBodyType = Phaser.Physics.P2JS;
                    teams.leftTeam.numFighters = 0;
                    teams.leftTeam.nextFighter = 0;
                    teams.leftTeamArr = new Array();
                    
                    //Initialize the right team
                    teams.rightTeam = game.add.group();
                    teams.rightTeam.enableBody = true;
                    teams.rightTeam.physicsBodyType = Phaser.Physics.P2JS;
                    teams.rightTeam.numFighters = 0;
                    teams.rightTeam.nextFighter = 0;
                    teams.rightTeamArr = new Array();
                    
                    //Initialize the Action Menu
                    actionMenu = new Object();
                    //State of the Menu: 1 is moving up, -1 is moving down, 0 is stationary
                    actionMenu.state = 0;
                    actionMenu.activeIcon = 0;
                    actionMenu.numIcons = 0;
                    actionMenu.moveRate = 4;
                    actionMenu.minYPos = game.height - ICON_WIDTH - BAR_HEIGHT;
                    actionMenu.maxYPos = game.height - BAR_HEIGHT;
                    actionMenu.xPos = 0;
                    actionMenu.yPos = actionMenu.minYPos;
                    actionMenu.icons = game.add.group();
                    actionMenu.iconArr = new Array();
                    actionMenu.activeIconOverlay = game.add.sprite(0, actionMenu.yPos + BAR_HEIGHT, 'activeiconoverlay');
                    actionMenu.activeIconOverlay.fixedToCamera = true;
                    actionMenu.activeIconOverlay.iconOffset = new Object();
                    actionMenu.activeIconOverlay.iconOffset.x = 0;
                    actionMenu.activeIconOverlay.iconOffset.y = BAR_HEIGHT;
                    actionMenu.activeIconOverlay.width = ICON_WIDTH;
                    actionMenu.activeIconOverlay.height = ICON_WIDTH;
                    actionMenu.moveBar = game.add.sprite(0, actionMenu.yPos, "blackbox");
                    actionMenu.moveBar.height = BAR_HEIGHT;
                    actionMenu.moveBar.fixedToCamera = true;
                    
                    objects = game.add.group();
                    objects.enableBody = true;
                    objects.physicsBodyType = Phaser.Physics.P2JS;
                    
                    var ground = spawnObject(MAP_WIDTH / 2, game.height - 10, 'ground', true, false);
                    
                    ground.body.friction = 1.0;
                    
                    
                    if (levelIdx == 0) {
                        //Load Level 0
                        //Load the terrain blocks
                        
                        //Load the fighters
                        //Make the first fighter be the one that is active first
                        var firstFighter = spawnFighter(MAP_WIDTH/2 - 40, game.height - 120, "paladin", 1);
                        var fighter = spawnFighter(MAP_WIDTH/2 + 200, game.height - 120, "paladin", 2);
                        //fighter = spawnFighter(MAP_WIDTH/2 - 40, game.height - 160, "paladin", 1);
                        //fighter = spawnFighter(MAP_WIDTH/2 + 200, game.height - 160, "paladin", 2);
                        //fighter = spawnFighter(MAP_WIDTH/2 - 40, game.height - 200, "paladin", 1);
                        //fighter = spawnFighter(MAP_WIDTH/2 + 200, game.height - 200, "paladin", 2);
                        
                        switchFighter(firstFighter);
                        
                    }
                }
                
                function deleteLevel() {
                    if (objects != null) {
                        objects.destroy();
                    }
                    if (teams != null) {
                        if (teams.leftTeam != null) {
                            teams.leftTeam.destroy();
                        }
                        if (teams.leftTeamArr != null) {
                            teams.leftTeamArr = [];
                        }
                        if (teams.rightTeam != null) {
                            teams.rightTeam.destroy();
                        }
                        if (teams.rightTeamArr != null) {
                            teams.rightTeamArr = [];
                        }
                        teams = null;
                    }
                    if (gameState.activeFighter != null) {
                        gameState.activeFighter.destroy();
                        gameState.activeFighter = null;
                    }
                    gameState.activeTeam = 1;
                    if (actionMenu != null) {
                        if (actionMenu.icons != null) {
                            actionMenu.icons.destroy();
                        }
                        if (actionMenu.activeIconOverlay != null) {
                            actionMenu.activeIconOverlay.destroy();
                        }
                        if (actionMenu.moveBar != null) {
                            actionMenu.moveBar.destroy();
                        }
                    }
                    if (projectiles.grenades != null) {
                        projectiles.grenades.destroy();
                        projectiles.grenades = game.add.group();
                        projectiles.grenades.enableBody = true;
                        projectiles.grenades.physicsBodyType = Phaser.Physics.P2JS;
                    }
                    if (projectiles.shards != null) {
                        projectiles.shards.destroy();
                        projectiles.shards = game.add.group();
                        projectiles.shards.enableBody = true;
                        projectiles.shards.physicsBodyType = Phaser.Physics.P2JS;
                    }
                    
                }
                
                //Spawns a physics object
                function spawnObject(xPos, yPos, texture, stationary, breakable) {
                    var block = objects.create(xPos, yPos, texture);
                    block.body.setCollisionGroup(objectCollisionGroup);
                    if (breakable) {
                        block.body.collides(grenadeCollisionGroup, blockCollision, this);
                        block.body.collides(projectiles, blockCollision, this);
                    }
                    else {
                        block.body.collides(grenadeCollisionGroup);
                        block.body.collides(shardCollisionGroup);
                    }
                    block.body.collides(objectCollisionGroup);
                    block.body.collides(fighterCollisionGroup);
                    block.body.kinematic = stationary;
                    
                    return block;
                }
                
                //Spawns a fighter
                function spawnFighter(xPos, yPos, type, teamNum) {
                    
                    var tileSheet = getFighterSprite(type);
                    
                    var fighter;
                    if (teamNum == 1) {
                        fighter = teams.leftTeam.create(xPos, yPos, tileSheet);
                        teams.leftTeamArr.push(fighter);
                        teams.leftTeam.numFighters++;
                    } else if (teamNum == 2) {
                        fighter = teams.rightTeam.create(xPos, yPos, tileSheet);
                        teams.rightTeamArr.push(fighter);
                        teams.rightTeam.numFighters++;
                    }
                    fighter.team = teamNum;
                    fighter.fighterType = type;
                    switch (fighter.fighterType) {
                        case ("paladin"):
                            fighter.jumpSpeed = fighterStats.paladin.jumpSpeed;
                            fighter.moveSpeed = fighterStats.paladin.moveSpeed;
                            fighter.maxDistance = fighterStats.paladin.maxDistance;
                            fighter.numJumps = fighterStats.paladin.numJumps;
                            fighter.attackRange = fighterStats.paladin.attackRange;
                            fighter.attackDamage = fighterStats.paladin.attackDamage;
                            fighter.maxHealth = fighterStats.paladin.maxHealth;
                            fighter.health = fighter.maxHealth;
                            break;
                    }
                    fighter.body.setCollisionGroup(fighterCollisionGroup);
                    fighter.body.collides(fighterCollisionGroup, fighterToFighterCollision, this);
                    fighter.body.collides(shardCollisionGroup, fighterCollision, this);
                    fighter.body.collides(objectCollisionGroup);
                    fighter.body.fixedRotation = true;
                    fighter.body.kinematic = true;
                    fighter.body.friction = 1.0;
                    fighter.startPosition = new Object();
                    fighter.startPosition.x = fighter.position.x;
                    fighter.startPosition.y = fighter.position.y;
                    fighter.distanceFromStart = 0;
                    fighter.outOfBounds = false;
                    fighter.previousYVel = 0;
                    fighter.animIdx = 0;
                    fighter.animState = "standing";
                    if (fighter.team == 1) {
                        fighter.animDir = "right";
                    } else if (fighter.team == 2) {
                        fighter.animDir = "left";
                    }
                    
                    return fighter;
                    
                }
                
                function update() {
                    //Check if the game is over
                    
                    switch (gameState.currentState) {
                        case ("game"):
                            updateGame();
                            break;
                        case ("selectmenu"):
                            
                            break;
                    }
                }
                
                function updateGame() {
                    var deltaTime = 1;
                    
                    updateGUI();
                    updateProjectiles(deltaTime);
                    updateFighters();
                    
                    processInput();
                    
                    game.world.bringToTop(actionMenu.moveBar);
                    game.world.bringToTop(actionMenu.icons);
                    game.world.bringToTop(actionMenu.activeIconOverlay);
                }
                
                function updateSelectMenu() {
                    
                }
                
                function processInput() {
                    inputManager.movingLeft = false;
                    //Check if a grenade needs to be spawned
                    if (game.input.activePointer.leftButton.isDown && !mouseWasDown) {
                        //spawnGrenade();
                        mouseWasDown = true;
                    }
                    else if (!game.input.activePointer.leftButton.isDown) {
                        mouseWasDown = false;
                    }
                    
                    //Keyboard input checks
                    if (inputManager.key_W.isDown) {
                        wDown();
                    }
                    if (inputManager.key_A.isDown) {
                        aDown();
                    }
                    if (inputManager.key_S.isDown) {
                        sDown();
                    }
                    if (inputManager.key_D.isDown) {
                        dDown();
                    }
                    if (inputManager.key_SPACEBAR.isDown) {
                        spaceDown();
                    }
                }
                
                function updateGUI() {
                    //Get the next y position of the GUI
                    var newYPos = actionMenu.yPos;
                    if (actionMenu.state == 1) {
                        console.log("MOVING UP");
                        newYPos -= actionMenu.moveRate;
                    } else if (actionMenu.state == -1) {
                        console.log("MOVING DOWN");
                        newYPos += actionMenu.moveRate;
                    }
                    //Check min/max boundaries
                    if (newYPos < actionMenu.minYPos) {
                        console.log("HIT MAX HEIGHT");
                        newYPos = actionMenu.minYPos;
                        actionMenu.state = 0;
                    } else if (newYPos > actionMenu.maxYPos) {
                        console.log("HIT MIN HEIGHT");
                        newYPos = actionMenu.maxYPos;
                        actionMenu.state = 0;
                    }
                    actionMenu.yPos = newYPos;
                    
                    //Update the y position of every icon in the GUI (if there are icons)
                    if (actionMenu.numIcons != 0) {
                        actionMenu.icons.forEach(function(icon) {
                            if (icon != null) {
                                icon.cameraOffset.x = actionMenu.xPos + icon.iconOffset.x;
                                icon.cameraOffset.y = actionMenu.yPos + icon.iconOffset.y;
                            }
                        });
                        actionMenu.activeIconOverlay.iconOffset.x = (actionMenu.activeIcon % actionMenu.numIcons) * ICON_WIDTH;
                        actionMenu.activeIconOverlay.cameraOffset.x = actionMenu.xPos + actionMenu.activeIconOverlay.iconOffset.x;
                        actionMenu.activeIconOverlay.cameraOffset.y = actionMenu.yPos + actionMenu.activeIconOverlay.iconOffset.y;
                        actionMenu.moveBar.cameraOffset.y = actionMenu.yPos;
                    }
                    
                    //Adjust the width of the movement bar based on the current active fighter's movement
                    if (gameState.activeFighter != null) {
                        var ratio = gameState.activeFighter.distanceFromStart / gameState.activeFighter.maxDistance;
                        if (ratio > 1) {
                            ratio = 1;
                        } else if (ratio < 0) {
                            ratio = 0;
                        }
                    } else {
                        ratio = 0;
                    }
                    actionMenu.moveBar.width = ratio * BAR_MAX_LENGTH;
                    
                    }
                
                function updateProjectiles(deltaTime) {
                    //Update grenades
                    projectiles.grenades.forEach(function(grenade) {
                        game.camera.follow(grenade);

                        //Update the grenade's angle if it has not already collided
                        if (!grenadeCollided && grenade.body.velocity.y != 0.0 && grenade.body.velocity.x != 0.0) {
                            grenade.body.angle = 180.0 * Math.atan((grenade.body.velocity.y) / (grenade.body.velocity.x)) / Math.PI;
                        }

                        grenade.timeRemaining--;
                        if (grenade.timeRemaining <= 0.0) {
                            //Grenade Explodes
                            explodeGrenade(grenade);
                            projectiles.grenades.remove(grenade);
                        }
                    });
                    
                    //Update shards
                    projectiles.shards.forEach(function(shard) {
                        if (shard != null) {
                            shard.timeRemaining -= deltaTime;
                            if (shard.timeRemaining <= 0) {
                                projectiles.shards.remove(shard);
                                shard.destroy();
                            }
                        }
                    });
                }
                
                function updateFighters() {
                    teams.leftTeam.forEach(function(fighter) {
                        //Slowly stopping the fighter
                        fighter.body.velocity.x *= 0.9;
                        
                        //Update the fighter's distance from their starting point and react accordingly
                        var xDiff = fighter.position.x - fighter.startPosition.x;
                        var yDiff = fighter.position.y - fighter.startPosition.y;
                        fighter.distanceFromStart = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
                        if (fighter.distanceFromStart >= fighter.maxDistance) {
                            fighter.outOfBounds = true;
                        } else {
                            fighter.outOfBounds = false;
                        }
                    });
                    teams.rightTeam.forEach(function(fighter) {
                        //Slowly stopping the fighter
                        fighter.body.velocity.x *= 0.9;
                        
                        //Update the fighter's distance from their starting point and react accordingly
                        var xDiff = fighter.position.x - fighter.startPosition.x;
                        var yDiff = fighter.position.y - fighter.startPosition.y;
                        fighter.distanceFromStart =  Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
                        if (fighter.distanceFromStart >= fighter.maxDistance) {
                            fighter.outOfBounds = true;
                        } else {
                            fighter.outOfBounds = false;
                        }
                    });
                    
                    //Reset the fighter's jumps if they are landing
                    //if (Math.round(gameState.activeFighter.body.velocity.y) == 0 && gameState.activeFighter.previousYVel > 0.0) {
                    if (Math.round(gameState.activeFighter.body.velocity.y) == Math.round(gameState.activeFighter.previousYVel)) {
                        loopAnim("standing");
                        switch (gameState.activeFighter.fighterType) {
                            case ("paladin"):
                                gameState.activeFighter.numJumps = fighterStats.paladin.numJumps;
                                break;
                        }
                    } else if (gameState.activeFighter.body.velocity.y > 0.0) {
                        //Player is falling
                        //playAnim("falling", "falling");
                    }
                    
                    gameState.activeFighter.previousYVel = gameState.activeFighter.body.velocity.y;
                    
                    updateAnim();
                    
                }
                
                function getFighterSprite(type) {
                    var tileSheet;
                    switch (type) {
                            case("paladin"):
                            tileSheet = "blackbox";
                            break;
                    }
                    
                    return tileSheet;
                }
                
                function copyFighter(fighter) {
                    var xPos = fighter.position.x;
                    var yPos = fighter.position.y;
                    var health = fighter.health;
                    var type = fighter.fighterType;
                    var teamNum = fighter.team;
                    var tilesheet = getFighterSprite(type);
                    
                    var newFighter;
                    if (teamNum == 1) {
                        teams.leftTeam.remove(fighter);
                        newFighter = teams.leftTeam.create(xPos, yPos, tilesheet);
                        teams.leftTeamArr.push(newFighter);
                        teams.leftTeamArr.splice(teams.leftTeamArr.indexOf(fighter), 1, newFighter);
                    } else if (teamNum == 2) {
                        teams.rightTeam.remove(fighter);
                        newFighter = teams.rightTeam.create(xPos, yPos, tilesheet);
                        teams.rightTeamArr.push(newFighter);
                        teams.rightTeamArr.splice(teams.rightTeamArr.indexOf(fighter), 1, newFighter);
                    }
                    fighter.destroy();
                    
                    newFighter.team = teamNum;
                    
                    //Initialize the fighter's type and its stats
                    newFighter.fighterType = type;
                    switch (newFighter.fighterType) {
                        case ("paladin"):
                            newFighter.jumpSpeed = fighterStats.paladin.jumpSpeed;
                            newFighter.moveSpeed = fighterStats.paladin.moveSpeed;
                            newFighter.maxDistance = fighterStats.paladin.maxDistance;
                            newFighter.numJumps = fighterStats.paladin.numJumps;
                            newFighter.attackRange = fighterStats.paladin.attackRange;
                            newFighter.attackDamage = fighterStats.paladin.attackDamage;
                            newFighter.maxHealth = fighterStats.paladin.maxHealth;
                            break;
                    }
                    newFighter.health = health;
                    newFighter.body.setCollisionGroup(fighterCollisionGroup);
                    newFighter.body.collides(fighterCollisionGroup, fighterToFighterCollision, this);
                    newFighter.body.collides(shardCollisionGroup, fighterCollision, this);
                    newFighter.body.collides(objectCollisionGroup);
                    newFighter.body.fixedRotation = true;
                    newFighter.body.kinematic = false;
                    newFighter.body.friction = 1.0;
                    newFighter.startPosition = new Object();
                    newFighter.startPosition.x = newFighter.position.x;
                    newFighter.startPosition.y = newFighter.position.y;
                    newFighter.distanceFromStart = 0;
                    newFighter.outOfBounds = false;
                    newFighter.previousYVel = 0;
                    
                    return newFighter;
                    
                    
                }
                
                function switchFighter(newFighter) {
                    if (gameState.activeFighter != null) {
                        if (gameState.activeFighter.team != newFighter.team) {
                            console.log("SWITCHING TEAMS");
                            gameState.activeFighter.body.velocity.x = 0;
                            gameState.activeFighter.body.velocity.y = 0;
                            gameState.activeFighter.body.kinematic = true;
                            gameState.activeFighter = null;
                        } else {
                            console.log("DID NOT SWITCH TEAMS");
                            console.log(gameState.activeFighter.team);
                            console.log(newFighter.team);
                        }
                    }
                    
                    var oldDir = newFighter.animDir;
                    newFighter = copyFighter(newFighter);
                    newFighter.animState = "standing";
                    newFighter.animDir = oldDir;
                    
                    gameState.activeFighter = newFighter;
                    game.camera.follow(gameState.activeFighter);
                    resetActionMenu(newFighter.fighterType);
                }
                
                function killFighter(fighter) {
                    if (fighter.team == 1) {
                        teams.leftTeam.remove(fighter);
                        teams.leftTeamArr.splice(teams.leftTeamArr.indexOf(fighter), 1);
                        teams.leftTeam.numFighters--;
                    } else if (fighter.team == 2) {
                        teams.rightTeam.remove(fighter);
                        teams.rightTeamArr.splice(teams.rightTeamArr.indexOf(fighter), 1);
                        teams.rightTeam.numFighters--;
                    }
                    if (fighter == gameState.activeFighter) {
                        gameState.activeFighter = null;
                    }
                    fighter.destroy();
                }
                
                function nextTurn() {
                    //Changes variables so the next fighter in line can take their turn
                    if (teams.leftTeam.numFighters == 0) {
                        console.log("********LEFT TEAM WINS***************************************************")
                        teams.rightTeam.nextFighter++;
                        teams.rightTeam.nextFighter = teams.rightTeam.nextFighter % teams.rightTeam.numFighters;
                        switchFighter(teams.rightTeamArr[teams.rightTeam.nextFighter]);
                    } else if (teams.rightTeam.numFighters == 0) {
                        console.log("**************************************************RIGHT TEAM WINS********")
                        teams.leftTeam.nextFighter++;
                        teams.leftTeam.nextFighter = teams.leftTeam.nextFighter % teams.leftTeam.numFighters;
                        switchFighter(teams.leftTeamArr[teams.leftTeam.nextFighter]);
                    } else {
                        console.log("*************************************************************************");
                        inputManager.state = "move";
                        gameState.activeTeam = (gameState.activeTeam % 2) + 1;
                        if (gameState.activeTeam == 1) {
                            teams.rightTeam.nextFighter++;
                            teams.rightTeam.nextFighter = teams.rightTeam.nextFighter % teams.rightTeam.numFighters;
                            switchFighter(teams.leftTeamArr[teams.leftTeam.nextFighter]);
                        }
                        else if (gameState.activeTeam == 2) {
                            teams.leftTeam.nextFighter++;
                            teams.leftTeam.nextFighter = teams.leftTeam.nextFighter % teams.leftTeam.numFighters;
                            switchFighter(teams.rightTeamArr[teams.rightTeam.nextFighter]);
                        }
                    }
                }
                
                function spawnGrenade() {
                    var grenade = projectiles.grenades.create(0, game.height - 50, 'grenade');
                    
                    grenade.body.velocity.x = GRENADE_VELOCITY * Math.cos((Math.PI * 45) / 180.0);
                    grenade.body.velocity.y = GRENADE_VELOCITY * Math.sin((Math.PI * 45) / 180.0);
                    //grenade.body.acceleration.y = GRAVITY;
                    //grenade.body.angle = cannon.angle;
                    grenade.body.collideWorldBounds = false;
                    grenade.timeRemaining = GRENADE_LIFETIME;
                    grenade.body.setCollisionGroup(grenadeCollisionGroup);
                    grenade.body.collides(objectCollisionGroup, grenadeCollision, this);
                    grenade.body.collides(fighterCollisionGroup, grenadeCollision, this);
                    
                    grenadeCollided = false;
                    
                }
                
                function explodeGrenade(grenade) {
                    spawnExplosion(grenade.body.x, grenade.body.y);
                    
                    grenade.destroy();
                    grenade = null;
                    console.log("GRENADE EXPLODED");
                    
                }
                
                function spawnExplosion(xPos, yPos) {
                    //A bunch of random projectiles that shoot out and destroy objects
                    spawnGrenadeShard(xPos, yPos, 0, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, Math.PI / 4, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, Math.PI / 2, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, (3 * Math.PI) / 4, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, Math.PI, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, (5 * Math.PI) / 4, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, (3 * Math.PI) / 2, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    spawnGrenadeShard(xPos, yPos, (7 * Math.PI) / 4, EXPLOSION_VELOCITY, EXPLOSION_LIFETIME);
                    
                }
                
                //Takes in an angle in radians(?)
                function spawnGrenadeShard(xPos, yPos, angle, velocity, lifetime) {
                    //Make sure the angle is between 0 and 2PI, but not equal to 2PI
                    while (angle < 0 || angle > 2 * Math.PI) {
                        if (angle < 0) {
                            angle += 2 * Math.PI;
                        }
                        else if (angle > 2 * Math.PI) {
                            angle -= 2 * Math.PI;
                        }
                    }
                    var shard = projectiles.shards.create(xPos, yPos, 'explosion');
                    shard.body.setCollisionGroup(shardCollisionGroup);
                    shard.body.collideWorldBounds = false;
                    shard.body.collides(objectCollisionGroup);
                    shard.body.collides(fighterCollisionGroup);
                    shard.body.velocity.x = velocity * Math.cos(angle);
                    shard.body.velocity.y = velocity * Math.sin(angle);
                    shard.timeRemaining = lifetime;
                }
                
                function grenadeCollision() {
                    grenadeCollided = true;
                }
                
                function blockCollision(body, shapeA, shapeB, equation) {
                    //Decrement the health of the block
                    if (body != null) {
                        body.sprite.health--;
                        //body.sprite.destroy();
                    }
                }
                
                function fighterToFighterCollision(body, shapeA, shapeB, equation) {
                    if (body != null) {
                        console.log("fighter collided");
                        //body.velocity.x = 0;
                        //body.velocity.y = 0;
                    }
                }
                
                function fighterCollision(body, shapeA, shapeB, equation) {
                    
                    
                }
                
                function playAnim(newState, frameAfter) {
                    gameState.activeFighter.animState = newState;
                    gameState.activeFighter.animIdx = 0;
                    gameState.activeFighter.animLoop = false;
                    
                    //Assign specific animation range here
                    //REMEMBER TO SET THE FRAMEAFTER ANIM TOO (the frame the player is paused at after this animation completes, staying at this frame until another animation is played)
                    switch (gameState.activeFighter.animDir) {
                        case ("right"):
                            
                            break;
                        case ("left"):
                            
                            break;
                    }
                }
                
                function loopAnim(newState) {
                    gameState.activeFighter.animState = newState;
                    gameState.activeFighter.animIdx = 0;
                    gameState.activeFighter.animLoop = true;
                    
                    //Assign specific animation range here
                    switch (gameState.activeFighter.animDir) {
                        case ("right"):
                            
                            break;
                        case ("left"):
                            
                            break;
                    }
                }
                
                function updateAnim() {
                    switch (gameState.activeFighter.animState) {
                        case ("standing"):
                            
                            break;
                        case ("running"):
                            
                            break;
                        case ("jumping"):
                            
                            break;
                        case ("falling"):
                            
                            break;
                    }
                }
                
                
                
                
                
                
                
                
                function wDown() {
                    console.log("W Down");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            aimUp();
                            break;
                        case ("observe"):
                            cameraMoveUp();
                            break;
                    }
                }
                
                function wPressed() {
                    console.log("W Pressed");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            //No Function
                            break;
                        case ("observe"):
                            //No Function
                            break;
                    }
                }
                
                function aDown() {
                    console.log("A Down");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            fighterMoveLeft();
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            //No Function
                            break;
                        case ("observe"):
                            cameraMoveLeft();
                            break;
                    }
                }
                
                function aPressed() {
                    console.log("A Pressed");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            menuMoveLeft();
                            break;
                        case ("aiming"):
                            cancelAiming();
                            break;
                        case ("observe"):
                            //No Function
                            break;
                    }
                }
                
                function sDown() {
                    console.log("S Down");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            aimDown();
                            break;
                        case ("observe"):
                            cameraMoveDown();
                            break;
                    }
                }
                
                function sPressed() {
                    console.log("S Pressed");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            toggleActionMenu();
                            break;
                        case ("action"):
                            toggleActionMenu();
                            break;
                        case ("aiming"):
                            //No Function
                            break;
                        case ("observe"):
                            //No Function
                            break;
                    }
                }
                
                function dDown() {
                    console.log("D Down");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            fighterMoveRight();
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            //No Function
                            break;
                        case ("observe"):
                            cameraMoveRight();
                            break;
                    }
                }
                
                function dPressed() {
                    console.log("D Pressed");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            menuMoveRight();
                            break;
                        case ("aiming"):
                            cancelAiming();
                            break;
                        case ("observe"):
                            //No Function
                            break;
                    }
                }
                
                function spaceDown() {
                    console.log("Space Down");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            //No Function
                            break;
                        case ("action"):
                            //No Function
                            break;
                        case ("aiming"):
                            //No Function
                            break;
                        case ("observe"):
                            //No Function
                            break;
                    }
                }
                
                function spacePressed() {
                    console.log("Space Pressed");
                    
                    switch (inputManager.state) {
                        case ("move"):
                            fighterJump();
                            break;
                        case ("action"):
                            selectAction();
                            break;
                        case ("aiming"):
                            fireProjectile();
                            break;
                        case ("observe"):
                            stopObserving();
                            break;
                    }
                }
                
                function fighterJump() {
                    console.log("Fighter jumped");
                    
                    if (gameState.activeFighter != null) {
                        if (gameState.activeFighter.numJumps > 0) {
                            gameState.activeFighter.body.velocity.y -= gameState.activeFighter.jumpSpeed;
                            gameState.activeFighter.numJumps--;
                            playAnim("jumping", "falling");
                        }
                    }
                }
                
                function fighterMoveLeft() {
                    console.log("Fighter moved left");
                    
                    if (gameState.activeFighter != null) {
                        if (!gameState.activeFighter.outOfBounds) {    
                            gameState.activeFighter.body.velocity.x = -1 * gameState.activeFighter.moveSpeed;
                            inputManager.movingLeft = true;
                            if (gameState.activeFighter.animState != "jumping") {
                                loopAnim("running");
                            }
                            gameState.activeFighter.animDir = "left";
                        } else {
                            if (gameState.activeFighter.startPosition.x <= gameState.activeFighter.position.x) {
                                gameState.activeFighter.body.velocity.x = -1 * gameState.activeFighter.moveSpeed;
                                inputManager.movingLeft = true;
                                if (gameState.activeFighter.animState != "jumping") {
                                    loopAnim("running");
                                }
                                gameState.activeFighter.animDir = "left";
                            } else {
                                gameState.activeFighter.body.velocity.x = 0;
                            }
                        }
                    }
                    
                }
                
                function fighterMoveRight() {
                    console.log("Fighter moved right");
                    
                    if (gameState.activeFighter != null) {
                        if (!inputManager.movingLeft) {
                            if (!gameState.activeFighter.outOfBounds) {
                                gameState.activeFighter.body.velocity.x = gameState.activeFighter.moveSpeed;
                                if (gameState.activeFighter.animState != "jumping") {
                                    loopAnim("running");
                                }
                                gameState.activeFighter.animDir = "right";
                            } else {
                                if (gameState.activeFighter.startPosition.x >= gameState.activeFighter.position.x) {
                                    gameState.activeFighter.body.velocity.x = gameState.activeFighter.moveSpeed;
                                    if (gameState.activeFighter.animState != "jumping") {
                                        loopAnim("running");
                                    }
                                    gameState.activeFighter.animDir = "right";
                                } else {
                                    gameState.activeFighter.body.velocity.x = 0;
                                }
                            }
                        } else {
                            gameState.activeFighter.body.velocity.x = 0;
                        }
                    }
                }
                
                function toggleActionMenu() {
                    console.log("Action menu toggled");
                    if (actionMenu.state == 0) {
                        if (actionMenu.yPos == actionMenu.maxYPos) {
                            console.log("Menu is moving up...");
                            actionMenu.state = 1;
                            inputManager.state = "action";
                        } else if (actionMenu.yPos == actionMenu.minYPos) {
                            console.log("Menu is moving down...");
                            actionMenu.state = -1;
                            inputManager.state = "move";
                            game.camera.follow(gameState.activeFighter);
                        } else {
                            //Case for when something weird is happening and you just want to restore the GUI
                            actionMenu.state = -1;
                            inputManager.state = "move";
                        }
                    }
                }
                
                function resetActionMenu(newFighterType) {
                    actionMenu.icons.destroy();
                    actionMenu.icons = game.add.group();
                    actionMenu.iconArr = new Array();
                    actionMenu.activeIcon = 0;
                    actionMenu.yPos = actionMenu.maxYPos;
                    actionMenu.state = 0;
                    var xOffset = 0;
                    var yOffset = BAR_HEIGHT;
                    var icon = null;
                    switch (newFighterType) {
                        case ("paladin"):
                            actionMenu.numIcons = 4;
                            icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                            actionMenu.iconArr.push(icon);
                            icon.iconOffset = new Object();
                            icon.iconOffset.x = xOffset;
                            icon.iconOffset.y = yOffset;
                            icon.width = ICON_WIDTH;
                            icon.height = ICON_WIDTH;
                            icon.fixedToCamera = true;
                            icon.relatedAction = "swordstrike";
                            
                            xOffset += ICON_WIDTH;
                            
                            icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                            actionMenu.iconArr.push(icon);
                            icon.iconOffset = new Object();
                            icon.iconOffset.x = xOffset;
                            icon.iconOffset.y = yOffset;
                            icon.width = ICON_WIDTH;
                            icon.height = ICON_WIDTH;
                            icon.fixedToCamera = true;
                            icon.relatedAction = "swordstrike";
                            
                            xOffset += ICON_WIDTH;
                            
                            icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                            actionMenu.iconArr.push(icon);
                            icon.iconOffset = new Object();
                            icon.iconOffset.x = xOffset;
                            icon.iconOffset.y = yOffset;
                            icon.width = ICON_WIDTH;
                            icon.height = ICON_WIDTH;
                            icon.fixedToCamera = true;
                            icon.relatedAction = "swordstrike";
                            
                            xOffset += ICON_WIDTH;
                            break;
                    }
                    actionMenu.numIcons++;
                    icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                    actionMenu.iconArr.push(icon);
                    icon.iconOffset = new Object();
                    icon.iconOffset.x = xOffset;
                    icon.iconOffset.y = yOffset;
                    icon.width = ICON_WIDTH;
                    icon.height = ICON_WIDTH;
                    icon.fixedToCamera = true;
                    icon.relatedAction = "observemode";
                    
                    xOffset += ICON_WIDTH;
                    
                    actionMenu.numIcons++;
                    icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                    actionMenu.iconArr.push(icon);
                    icon.iconOffset = new Object();
                    icon.iconOffset.x = xOffset;
                    icon.iconOffset.y = yOffset;
                    icon.width = ICON_WIDTH;
                    icon.height = ICON_WIDTH;
                    icon.fixedToCamera = true;
                    icon.relatedAction = "endturn";
                    
                    xOffset += ICON_WIDTH;
                    
                    actionMenu.numIcons++;
                    icon = actionMenu.icons.create(actionMenu.xPos + xOffset, actionMenu.yPos + yOffset, "graybox");
                    actionMenu.iconArr.push(icon);
                    icon.iconOffset = new Object();
                    icon.iconOffset.x = xOffset;
                    icon.iconOffset.y = yOffset;
                    icon.width = ICON_WIDTH;
                    icon.height = ICON_WIDTH;
                    icon.fixedToCamera = true;
                    icon.relatedAction = "tomainmenu";
                    
                    xOffset += ICON_WIDTH;
                    
                }
                
                function menuMoveLeft() {
                    console.log("Menu selection moved left");
                    actionMenu.activeIcon--;
                    if (actionMenu.activeIcon < 0) {
                        actionMenu.activeIcon = actionMenu.numIcons - 1;
                    }
                }
                
                function menuMoveRight() {
                    console.log("Menu selection moved right");
                    actionMenu.activeIcon++;
                }
                
                function selectAction() {
                    console.log("Action selected");
                    
                    if (gameState.activeFighter.animState != "falling" && gameState.activeFighter.animState != "jumping") {
                        //Get the action the player wants to take
                        var iconNum = actionMenu.activeIcon % actionMenu.numIcons;
                        if (iconNum >= 0 && iconNum < actionMenu.numIcons) {
                            if  (actionMenu.iconArr[iconNum] != null) {
                                var action = actionMenu.iconArr[iconNum].relatedAction;

                                console.log(action);

                                //Apply that action
                                switch (action) {
                                    case ("observemode"):
                                        toggleActionMenu();
                                        game.camera.unfollow();
                                        inputManager.state = "observe";
                                        break;
                                    case ("swordstrike"):
                                        swordStrike();
                                        nextTurn();
                                        break;
                                    case ("endturn"):
                                        nextTurn();
                                        break;
                                    case ("tomainmenu"):
                                        toSelectMenu();
                                        break;
                                    //Make a case for rangedattack later
                                }
                            } else {
                                console.log("ACTION WAS NULL");
                            }
                        } else {
                            console.log("OUT OF ACTION BOUNDS");
                        }
                    }
                    
                    
                    
                }
                
                function swordStrike() {
                    console.log("SWORDSTRIKE");
                    //Determine the team that is attacking
                    var attackingTeam = gameState.activeFighter.team;
                    //Attacking Hitbox Points
                    var xPos = gameState.activeFighter.x + gameState.activeFighter.width / 2;
                    var yPos = gameState.activeFighter.y;
                    var width = 0;
                    if (gameState.activeFighter.animDir == "left") {
                        width = -gameState.activeFighter.attackRange;
                    } else if (gameState.activeFighter.animDir == "right") {
                        width = gameState.activeFighter.attackRange;
                    }
                    var height = gameState.activeFighter.height;
                    
                    //Check which fighters get hit
                    if (attackingTeam == 1) {
                        //Left team is attacking: loop through right team
                        teams.rightTeam.forEach(function(fighter) {
                            var currentXPos = fighter.x + fighter.width / 2;
                            var currentYPos = fighter.y + fighter.height / 2;

                            if (((currentXPos < xPos + width && currentXPos > xPos) || (currentXPos > xPos + width && currentXPos < xPos))
                                && ((currentYPos < yPos + height && currentYPos > yPos) || (currentYPos > yPos + height && currentYPos < yPos))) {
                                //Fighter gets hit
                                fighterHit(fighter, gameState.activeFighter.attackDamage);
                            }

                        });
                    } else if (attackingTeam == 2) {
                        //Right team is attacking: loop through left team
                        teams.leftTeam.forEach(function(fighter) {
                            var currentXPos = fighter.x + fighter.width / 2;
                            var currentYPos = fighter.y + fighter.height / 2;

                            if (((currentXPos < xPos + width && currentXPos > xPos) || (currentXPos > xPos + width && currentXPos < xPos))
                                && ((currentYPos < yPos + height && currentYPos > yPos) || (currentYPos > yPos + height && currentYPos < yPos))) {
                                //Fighter gets hit
                                fighterHit(fighter, gameState.activeFighter.attackDamage);
                            }
                        });
                    }
                }
                
                function fighterHit(fighter, damage) {
                    console.log("FIGHTER HIT");
                    fighter.health -= damage;
                    if (fighter.health <= 0) {
                        //Fighter dies
                        //Play death anim
                        playAnim(fighter, "death", "knockeddown");
                        //At end of anim, kill fighter
                        killFighter(fighter);
                        console.log("FIGHTER KILLED");
                    } else {
                        //Play hit anim
                        playAnim(fighter, "hit", "standing");
                    }
                    console.log(fighter.team);
                }
                
                function aimUp() {
                    console.log("Aimed higher up");
                }
                
                function aimDown() {
                    console.log("Aimed further down");
                }
                
                function cancelAiming() {
                    console.log("Stopped aiming");
                }
                
                function fireProjectile() {
                    console.log("Fired projectile");
                }
                
                function cameraMoveUp() {
                    game.camera.y -= CAMERA_SPEED;
                }
                
                function cameraMoveLeft() {
                    game.camera.x -= CAMERA_SPEED;
                }
                
                function cameraMoveDown() {
                    game.camera.y += CAMERA_SPEED;
                }
                
                function cameraMoveRight() {
                    game.camera.x += CAMERA_SPEED;
                }
                
                function stopObserving() {
                    console.log("Exiting observation mode");
                    inputManager.state = "action";
                    toggleActionMenu();
                }
            };

        </script>

    </body>
</html>